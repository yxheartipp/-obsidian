---
alias: []
Type: 
tags: ["#review"]
sr-due: 2024-05-10
sr-interval: 1
sr-ease: 250
---

# Pliops
通过硬件加速的方式，使用FPGA对刷盘数据提前进行排序，通过FPGA进行hash计算为每一个用户key生成定长值，依次来保证磁盘的寿命。
因为FPGA的运算效率相较于主机CPU高出10倍以上，所以采用了消耗算力最高的压缩比最高的压缩算法。这就保证了用较小的存储空间存储了较大的内容。
每一个加速卡可以负载7个SSD的计算量。向外界提供45GB/s 的读取6.4GB/S的写入速度。同时自带电源保证了cache的稳定。
基于以上硬件 Pliops对外暴露了Get/Put/Delete等KV接口，RocksDB通过Pliops闭源的libxdprocks调用Get/Put/Delete等KV接口。
Pliops在大Value的情况下表现较好
![[Pasted image 20240509180637.png]]
在4K以上的写入速度可以加速到27倍，但在512bytes上的加速效果只有10倍左右。
![[piops实现.png]]
## KVROCK的实践
#### **硬件配置**
该实验的服务器使用了:
- CPU: `AMD EPYC 7543 32` 核处理器，2 路 CPU，32 核，128 线程
- 内存容量: `512GB`
- 存储容量：共 `15TB`，4 块三星 PM9A3，3.84 TB Gen 4 固态硬盘
- 操作系统版本： CentOS 7.9
其中，2 块 SSD 被分配给 `sw`，另外 2 块被分配给 `kvxdprocks`，分别使用的总存储容量为 7TB。
**Kvrocks 配置**
- worker 线程数: 32
- RocksDB Block Cache：每个服务进程 16GB（总计 128GB）
- RocksDB Block Size： 4KB
- Pipeline: 8
- 压测类型：默认字符串类型的 Get 和 Set 操作
在512b上
![[Pasted image 20240509181006.png]]
与直接使用主机测相比，xdp提高了1.4到3.4倍的写入吞吐量，无法达到Pliops在实验报告中承诺的95倍的加速效果，以及3.3倍的CPU效率降低。
# POLARDB-X

将FPGA作为小型CPU通过PCIe直接与存储介质沟通，直接使用FPGA对所有compaction进行offload。主机侧CPU之负责compaction任务的生产和调度。
当L0层的SSTable数量达到阈值时，compaction任务会被触发，compaction的offload分为以下几个步骤：
1. 从持久化存储中load需要compaction的SSTable，CPU通过meta信息按照data block的粒度拆分成多个compaction任务，并且为每个compaction任务的计算结果预分配内存空间，每一个构建好的compaction任务都会被压入到Task Queue队列中，等待FPGA执行；
2. CPU读取FPGA上Compaction Unit的状态，将Task Queue中的compaction任务分配到可用的Compaction Unit上；
3. 输入数据通过DMA传输到FPGA的DDR上；
4. Compaction Unit执行Compaction任务，计算完成后，结果通过DMA回传给host，并且附带return code指示此次compaction任务的状态（失败或者成功），执行完的compaction结果会被压入到Finished Queue队列中；
5. CPU检查Finished Queue中compaction任务的结果状态，如果compaction失败，该任务会被CPU再次执行；
6. compaction的结果flush到存储。
![[Pasted image 20240509182337.png]]
X-Engine 在FPGA上的对于小value有较明显的提升，可以看到写入普遍的吞吐量毛刺较温和，CPU依然负责了compaction进行整体吞吐量提升了 **40%** 。
## 参考文献
[Pliops](https://zhuanlan.zhihu.com/p/576961926)
[X-Engine](https://zhuanlan.zhihu.com/p/35450235)
